/*******************************************************************************
 *    Copyright (c) 2018 Jonathan A. Saddler
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 *    
 *    Contributors:
 *     Jonathan A. Saddler - initial API and implementation
 *******************************************************************************/

package edu.unl.cse.efs.java;

import java.awt.Component;
import java.awt.Window;
import java.io.IOException;
import java.util.*;

import edu.umd.cs.guitar.model.*;
import edu.umd.cs.guitar.model.data.*;
import edu.umd.cs.guitar.model.wrapper.JavaExtractFilteredGUIProperties;
import edu.umd.cs.guitar.replayer.GReplayerMonitor;
import edu.umd.cs.guitar.replayer.JFCReplayerMonitor;
import edu.umd.cs.guitar.ripper.filter.GComponentFilter;
import edu.unl.cse.efs.ApplicationData;
import edu.unl.cse.efs.replay.ApplicationMonitor;
import edu.unl.cse.guitarext.StateDump;

/**
 * The JavaApplicationMonitor is a class responsible for storing the state of
 * the application abstraction, and keeping track of the states
 * of the application under test. We can potentially attach listeners to windows
 * from the application generated by this monitor. This class contains a state dump
 * that after it is initialized, will prepare a file that stores the state of
 * the application. The state dump file can then be written on demand. 
 * 
 * The JavaApplication monitor also extracts state information from Windows and Components 
 * in the java application that this monitor is monitoring. 
 * 
 * @author Jonathan Saddler
 */
public class JavaApplicationMonitor extends ApplicationMonitor {

	private JFCReplayerMonitor javaRepMonitor;
	private final JavaLaunchApplication launchApp;
	public StateDump currentStateDump;
	private boolean dumpReady;
	private boolean dumpBroken;
	private boolean recordStateDumps;
	private LinkedList<GComponentFilter> filtersInUse;
	private static ObjectFactory schemaFactory = new ObjectFactory();
	
	/**
	 * Constructor for the JavaApplicationMonitor. 
	 * Initializes the JavaLaunchApplication that this monitor will
	 * rely upon. 
	 * 
	 * Preconditions: 	none
	 * Postconditions:	the JavaLaunchApplication is set. 
	 */
	public JavaApplicationMonitor(JavaLaunchApplication javaLaunchThread)
	{
		//set the launch Application
		super(javaLaunchThread);
		launchApp = javaLaunchThread;
		dumpReady = false;
		dumpBroken = false;
		recordStateDumps = false;
	}
	
	public JavaApplicationMonitor(JavaLaunchApplication javaLaunchThread, boolean stateDumpsOn)
	{
		//set the launch Application
		super(javaLaunchThread);
		launchApp = javaLaunchThread;
		dumpReady = false;
		dumpBroken = false;
		recordStateDumps = stateDumpsOn;
	}
	/**
	 * Return whether a state dump should be initialized for this JavaApplicationMonitor
	 * @return
	 */
	public boolean stateDumpsOn()
	{
		return recordStateDumps;
	}
	
	public void setStateDumpsOn(boolean on)
	{
		recordStateDumps = on;
	}
	
	public void setupFilters(Collection<GComponentFilter> theFilters)
	{
		this.filtersInUse = new LinkedList<>(theFilters);
	}
	
	/**
	 * Return filters that should be used in the standard ripping procedure. 
	 */
	public static LinkedList<GComponentFilter> getStandardFilters()
	{ 
		// there are currently no standard filters.
		return new LinkedList<GComponentFilter>();
	}
	
	/**
	 * jsaddler: Will return the java launcher thread this monitor is using 
	 * holds.
	 * @return
	 */
	public JavaLaunchApplication getLauncher()
	{
		return launchApp;
	}
	
	/**
	 * The method must return all the top windows
	 * present in the OS of the host. Aforetime, the 
	 * replayerMonitor would do this using its host application.
	 */
	@Override
	public List<GWindow> getAllTopWindows() 
	{
		return new LinkedList<GWindow>(launchApp.getAppAbstraction().getAllWindow());
	}

	/**
	 * Special method to get application defined windows from the launchApplication. 
	 * @return
	 */
	public Set<Window> getAppRelatedAWTWindows()
	{
		return launchApp.getAppRelatedAWTWindows();
	}
	
	/**
	 * get the APP Related GWindows (Guitar window-wrapper objects) from this Application Monitor. 
	 * @return
	 */
	public Set<GWindow> getAppRelatedGWindows()
	{
		return launchApp.getAppRelatedGWindows();
	}
	/**
	 * This method must return all the root windows of the current application.
	 * (This excludes cogtoolhelper's main window, which will get captured if we're not careful to exclude it.)
	 * 
	 * Preconditions: 	a javaLaunchApplication is running and windows from its GUI can be ripped. 
	 * Postconditions: 	All application related GWindows from this JavaLaunchApplication are returned from the function. 					
	 */
	@Override
	public List<GWindow> getRootWindows() 
	{
		return new LinkedList<GWindow>(getAppRelatedGWindows());
	}

	/**
	 * Initialize a new stateDump file on the fly.
	 * 
	 * Preconditions: 	(none)
	 * Postconditions: 	State dump is not initialized if the filename specified could not be written to
	 * 					Otherwise state dump is initialized with a unique filename.
	 * 					If a dump file already exists with the specified filename, a number
	 * 					is appended to the filename to differentiate it from other filenames.
	 */
	public void setupStateDump(String filename)
	{
		try {
			currentStateDump = new StateDump(filename);
			if(currentStateDump.isDirectory())
				throw new IOException("File specified is a directory");
			int dumpCount = 1;
			while(currentStateDump.exists()) {
				dumpCount++;
				String newFilename;
				if(filename.lastIndexOf('.') != -1) {
					// get first part
					newFilename = filename.substring(0, filename.lastIndexOf('.'));
					// get last part
					newFilename += "_" + dumpCount + filename.substring(filename.lastIndexOf('.'));
				}
				else
					newFilename = filename + "_" + dumpCount;
				currentStateDump = new StateDump(newFilename);	
			}
			dumpReady = true;
		}
		catch(IOException e) {
			System.err.println("JavaApplicationMonitor: Could not initialize dump file: " + e.getLocalizedMessage());
			dumpBroken = true;
			dumpReady = false;
		}
	}
	
	/**
	 * Document the current state as recorded by the state dumper to the file specified in setupStateDump.
	 * setupStateDump() must be called previous to a call to this method. Otherwise, 
	 * this method will not function properly.
	 * 
	 * Preconditions: 	the stateDump was set up properly, 
	 * 					The user currently has write access to the path that was set up in setupStateDump
	 * Postconditions: 	If the dump is ready, a new file named by the name given in setupStateDump exists on the file
	 * 					system  containing the current state. 
	 * 					Else, the file containing the new state may or may not exist on the file system.
	 */
	public void dumpStateToFile()
	{
		if(!dumpReady && !dumpBroken) {
			System.err.println("JavaApplicationMonitor: Dump cannot be written at this time:\n"
					+ "Dump was not properly initialized.");
			return;
		}
		
		try {
			currentStateDump.writeContentToFile();
			System.out.println("--\nState Dump: DUMP FILE OF STATE WRITTEN TO: \n" 
					+ currentStateDump.getAbsolutePath() + "\n--\n");
		} 
		catch(IOException e) {
			System.err.println("JavaApplicationMonitor: Dump cannot be written at this time:\n"
					+ "Cannot access file: " + e.getMessage());
		}
	}
	
	/**
	 * This method will return a GUIStructure containing the head windows
	 * of this application, containing buttons widgets and all.
	 * 
	 * Preconditions: 	a javaLaunchApplication is running and windows from its GUI can be ripped. 
	 * Postconditions: 	A GUIStructure is returned containing information from all windows and inner widgets of the
	 * 					javaLaunchApplication that has been instantiated for this java application monitor.
	 */
	@Override
	public GUIStructure getCurrentState() 
	{
		GUIStructure appState = schemaFactory.createGUIStructure();
		List<GWindow> roots = getRootWindows();
		List<GUIType> guis = new ArrayList<GUIType>();

		for(GWindow rootWindow : roots) {
			rootWindow.setRoot(true);
			guis.add(extractWindow(rootWindow));
		}
		
		appState.setGUI(guis);
		return appState;
	}
	
	
	/**
	 * Extract window component information from the window provided
	 * Then modify the window to contain component information
	 * in its componentType object.
	 * 
	 * Preconditions: 	window is not null
	 * Postconditions: 	
	 */
	private GUIType extractWindow(GWindow window) {
		try {
			GUIType toReturn = window.extractWindow();
			GComponent gWinContainer = window.getContainer();
			ComponentType container;
			if(gWinContainer != null) {
				container = extractComponent(gWinContainer, window);
				if(container != null)
					// only here do we actually modify the window if it isn't null
					toReturn.getContainer().getContents().getWidgetOrContainer().add(container);
			}
			return toReturn;

		} catch (Exception e) {
			System.err.println("JavaApplicationMonitor: Transfiguration error:");
			e.printStackTrace();
			return null;
		}
	}
	
	/**
	 * Collect information about some GComponent and return the ComponentType containing
	 * information about the component.  
	 */
	private ComponentType extractComponent(GComponent component, GWindow window) 
	{
		// 1. Rip special/customized components
		
		LinkedList<GComponentFilter> filters = getStandardFilters();
		filters.addAll(filtersInUse);
		for(GComponentFilter filter : filters) 
			if(filter.isProcess(component, window))
				return filter.ripComponent(component, window);
		
		// we will only use component filters if they are useful
		// for now CogToolHelper Java will not use component filters
		// 2. Rip by the normal rules. 
		
		ComponentType toReturn;
		try {
			JFCXComponent jfcComp = (JFCXComponent)component;
			Component javaTarget = jfcComp.getComponent();
			toReturn = JavaExtractFilteredGUIProperties.extractComponentType(javaTarget);
			if(toReturn == null)
				toReturn = jfcComp.extractProperties();
			
			List<GComponent> children = component.getChildren();
			for(int i = 0; i < children.size(); i++) {
				GComponent child = children.get(i);
				ComponentType javaChild = extractComponent(child, window);
				if(javaChild != null && !javaChild.getAttributes().getProperty().isEmpty()) {
//					if(toReturn instanceof ContainerType) {
//					try {
//						((ContainerType) retComp).getContents().getWidgetOrContainer().add(guiChild);
//					} 
					try {
						((ContainerType)toReturn).getContents()
							.getWidgetOrContainer().add(javaChild);
					} 
					catch (java.lang.ClassCastException e) {
						System.out.println("ClassCastException");
						e.printStackTrace();
						throw e;
					}
				}
			}
		}
		catch(Exception e) {
			e.printStackTrace();
			return null;
		}
		
		//if(toReturn != null && dumpReady) currentStateDump.addExtraProperties(toReturn.getAttributes().getProperty());
		if(toReturn != null && dumpReady) currentStateDump.addExtraAttributes(toReturn.getAttributes());
		
		return toReturn;
	}

	/**
	 * jsaddler: start the application. Attempts to maximize windows after a delay. 
	 * Also delays after opening app windows. 
	 * 
	 * Preconditions: 	none
	 * Postconditions: 	the java application of this monitor is started. 
	 */
	@Override
	public void startApp() 
	{
		Thread newJavaAppThread = new Thread(launchApp);
		newJavaAppThread.start();
		
		//maximize windows
		try {
			System.out.println("JavaApplicationMonitor: Application Started.");
			Thread.sleep(ApplicationData.maximizeDelay);
		} catch(InterruptedException e) {
			System.err.println(e.getCause() + "\n" + e.getMessage());
			e.printStackTrace();
		}
		System.out.println("JavaApplicationMonitor: Now maximizing windows.");
		launchApp.maximizeAppWindows();
		
		// wait to release program control.
		try {
			System.out.println("JavaApplicationMonitor: Waiting " + ApplicationData.openWaitTime/1000 + " seconds for java app to settle.\n");
			Thread.sleep(ApplicationData.openWaitTime);
		} catch(InterruptedException e) {
			System.out.println(e.getMessage() + "\n" + e.getCause());
			e.printStackTrace();
		}
	}

	/**
	 * jsaddler: Close the last opened application instance.
	 * 
	 * Preconditions: none
	 * Postconditions: 	If the java application was open, it is now closed. 
	 */
	@Override
	public void closeApp() 
	{
		launchApp.closeApplicationInstances();
	}

	/**
	 * Re-initialize the replayer monitor
	 * 
	 * Preconditions: 	the app abstraction specified in launchApp has been run at least one time. 
	 * Postconditions: 	javaRepMonitor is instantiated using the main class name of the abstraction
	 * 					stored in this monitor's JavaLaunchApplication.
	 */
	@Override
	public void restart() 
	{
		String mainClassName = launchApp.getAppAbstraction().getJavaMainClass().getName();
		javaRepMonitor = new JFCReplayerMonitor(mainClassName);
	}

	/**
	 * Instantiates this JavaApplicationMonitor's replayer monitor, and returns it. 
	 * 
	 * Preconditions: 	the app abstraction specified in launchApp has been run at least one time. 
	 * Postconditions: 	javaRepMonitor is instantiated using the same class name as before. 
	*/
	@Override
	public GReplayerMonitor getReplayerMonitor() 
	{	
		String mainClassName = launchApp.getAppAbstraction().getJavaMainClass().getName();
		javaRepMonitor = new JFCReplayerMonitor(mainClassName);
		return javaRepMonitor;
	}
}
